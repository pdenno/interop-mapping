\documentclass[9pt,letterpaper]{article}
% Some useful packages for including images, colored font, etc.
\usepackage{url}
\usepackage[yyyymmdd,hhmmss]{datetime}
\usepackage{pdfsync}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{outline}
\usepackage{dsfont}
\usepackage{comment}
\usepackage{lmodern}
\usepackage{cite}
\usepackage{float}
\usepackage{appendix}
\usepackage{fancyvrb}
\usepackage{hyperref} % for href
\usepackage{textcomp} % has bullet, copyright symbols, etc.

\usepackage{inconsolata} % https://tex.stackexchange.com/questions/50810/good-monospace-font-for-code-in-latex
%\usepackage{courier}    % Alternative monospace. Inconsolata is a bit rougher, but distinguishes ( from { better.

\usepackage{listings,xcolor} % See https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings about minted rather than this.

\usepackage{graphicx}
\graphicspath{{./figures/}}
\graphicspath{{figures/}}

\bibliographystyle{unsrt}
\usepackage{fancyhdr}
\usepackage{datetime}
\fancyhf{}
\fancyhead[C]{\today\ DRAFT page \thepage}
\pagestyle{fancy}

% This is only useful for courier; not needed for inconsolata.
%\newcommand{\stt}[1]{\begin{footnotesize}\texttt{#1}\end{footnotesize}}
\newcommand{\stt}[1]{\texttt{#1}} % I use this on Mint5.

\usepackage{makecell}      % cells in tables to handle multiline content (see Ch5)
\usepackage{hhline}        % more stuff for tables

\usepackage{geometry} % https://www.overleaf.com/learn/latex/Page_size_and_margins#Paper_size.2C_orientation_and_margins
 \geometry{
%  a4paper,
%  total={170mm,257mm},
   left=30mm,
   right=30mm,
   top=25mm,
 }

 % ^^3f is a question mark (UTF-8)

% Begin JavaScript listinglst --------------------------------

\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{myred}{rgb}{0.8,0.2,0.2}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize,        % the size of the fonts that are used for the code
breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
breaklines=true,                 % sets automatic line breaking
captionpos=b,                    % sets the caption-position to bottom
commentstyle=\color{mygreen},    % comment style
deletekeywords={...},            % if you want to delete keywords from the given language
escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%pod frame=single,               % adds a frame around the code
keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue},       % keyword style
%language=JavaScript,            % the default language of the code  CANNOT BE SET.
morekeywords={*,...},            % if you want to add more keywords to the set
numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt,                   % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false,          % underline spaces within strings only
showtabs=false,                  % show tabs within strings adding particular underscores
stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve},     % string literal style
tabsize=2,                       % sets default tabsize to 2 spaces
title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%

\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{darkblue}{rgb}{.3,.3,.9}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

%define Javascript language (modified for  RADmapper)
\lstdefinelanguage{JavaScript}{
  keywords={\$abs, \$append, \$assert, \$average, \$base64decode, \$base64encode, \$boolean, \$ceil, \$contains, \$count, \$decodeUrl, \$decodeUrlComponent, \$distinct, \$each, \$encodeUrl, \$encodeUrlComponent, \$error, \$eval, \$exists, \$filter, \$floor, \$formatBase, \$formatInteger, \$formatNumber, \$fromMillis, \$join, \$keys, \$length, \$lookup, \$lowercase, \$map, \$match, \$max, \$merge, \$millis, \$min, \$not, \$now, \$number, \$pad, \$parseInteger, \$power, \$random,,\$read, \$reduce, \$replace, \$reverse, \$round, \$shuffle, \$sift, \$single, \$sort, \$split, \$spread, \$sqrt, \$string, \$substring, \$substringAfter, \$substringBefore, \$sum, \$toMillis, \$trim, \$type,,\$uppercase, \$zip},
keywordstyle=\color{darkblue}\bfseries,            % for \bfseries to be useful for Inconsolata, you may have to download the font: https://tex.stackexchange.com/questions/145833/inconsolata-bold-on-old-ubuntu-precise-texlive
ndkeywords={false, function, express, key, query, true} % You'll find it at https://www.ctan.org/tex-archive/fonts/inconsolata/
ndkeywordstyle=\color{darkgray}\bfseries,          % https://tex.stackexchange.com/questions/7669/bfseries-is-to-textbf-as-what-is-to-textsf explains names like 'bfseries'.
identifierstyle=\color{black},
sensitive=false,
morecomment=\bfseries[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{myred}\ttfamily,
morestring=[b]',
morestring=[b]"
}
% End JavaScript listinglst -------------------------------


\begin{document}
\title{Draft OAGi Interoperable Mapping Specification}
\author{OAGi Members}
\maketitle

\section{Introduction}
This document describes a data mapping language designed to serve as an \textit{interoperable exchange form} for expressing the intent of many mapping and data restructuring needs.
As an interoperable exchange form, it is intended that the language can be translated (by humans and machine agents) into mapping specification in other languages.
For example, it should be possible to translate statements in the exchange form into mapping specifications used by commercial mapping tools.
%OAGi members can find the most recent version of this document in the \textit{OAGi Mapping Specification Working Group} Confluence pages (under ``Mapping Doc'').

RADmapper, the mapping language, integrates JSONata expression language~\cite{Jsonata.org2021} with Datalog~\cite{Abiteboul1995a} capabilities. It currently supports mapping to/from JSON, XML, tables (e.g. Excel), and knowledge graphs (RDF).
Use cases for the RADmapper language including in-place updating of target data sources, and mapping from multiple sources.

%The document describes the RADmapper language and its strategy for serving as an interoperable exchange form mapping specifications.
As of this writing, a strategy for interoperable exchange of mapping specifications is under development. % ; these are discussed.
There is also on-going exploratory work for RADmapper to support streaming data.
These two topic are currently not discussed.
The reference implementation of the RADmapper language can be found in the Github repository \href{https://github.com/pdenno/RADmapper}{https://github.com/pdenno/RADmapper}.
An web-based ``exerciser'' tool to explore the language is available as a Docker image
\href{https://hub.docker.com/r/podenno/rm-exerciser}{https://hub.docker.com/r/podenno/rm-exerciser}.
The document is a draft and, as of this writing (\today), is likely to be updated often, as will the language implementation and exerciser.
%Whether or not the tool is useful for transforming information in real-world settings remains to be seen;
%we'll generate an OpenAPI Specification for the tool to test that idea.

% Discussion of the AST idea and the role of "RADmapper language" in that.

% At the current state of development, it isn't clear whether the language being described is the interoperable exchange form itself or something derived from the executable language being developed.
% For example, it is possible that abstract syntax trees (ASTs) of content in the language being described could themselves be transformed
% into the actual exchange form.
%The same process could possibly be used to produce ``mapping tables'', spreadsheets provided to programmers to hand-code the transformations
%in their system's native programming language. %A diagram would help here.
%In this light, the RADmapper tool can be thought of as means to get the intent of the mapping correct before handing it off to programmers.
% But this discussion is getting ahead of itself; the next section surveys key aspects of the language.

\section{Quick Start: Example Mapping Tasks}

This section uses examples to describe the basic features of the RADmapper language.
RADmapper provides the complete expression language and all the built-in functions of JSONata.
Examples of JSONata can be found in the \href{https://jsonata.org/}{JSONata specification}.
This section only goes into detail about the capabilities of RADmapper not found in JSONata.
The principal concepts to discuss are

\begin{itemize}
  \item{the relational and graph forms of data,}
  \item{RADmapper's \stt{query} declaration, used to query relational data,}
  \item{RADmapper's \stt{express} declaration, used to reorganize (``map'') data from its original form to the form in which it is needed, and}
  \item{RADmapper's strategy for interoperability. [Not yet!]}
\end{itemize}

%  The original form of data is called a \textit{source} form; the needed form is called the \textit{target} form.

\subsection{Data Organized as Triples and the query Construct}

\stt{query} is the principal construct of RADmapper providing Datalog-like functionality to the language.
\stt{query} declarations are used like JSONata or Javascript function declaration in the sense that the value of the declaration (a function) can be assigned to variables and used directly.
For example,
\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
$addOne := function(x){x + 1}
\end{lstlisting} \vspace{-2em}
defines a function and assigns it to the variable \stt{\$addOne}.
\stt{\$addOne(3)} is a call to the function with the argument 3.
Similarly,
\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
$myQuery := query(){[$DB1 ?person :age 42]}
\end{lstlisting} \vspace{-2em}
defines a query that can be used like a function.
\stt{\$myQuery(\$myDB)} is a call to the function with whatever ``database'' is assigned to \stt{\$myDB}.
However, unlike ordinary functions, the body of a \stt{query} consists of one or more \textit{Datalog patterns} such as the pattern \stt{[\$DB1 ?person :age 42]} shown.
We'll start by talking about the database argument to the query, for example, the value assigned to \stt{\$MyDB} in the expression \stt{\$myQuery(\$MyDB)} then get back to talking about the patterns.

Relational (table-based) and graph-based data can be described by triples $[x,rel,y]$ where $x$ is an entity reference, $y$ is data (string, number, entity reference, etc.) and $rel$ is a relationship (predicate) holding between $x$ and $y$.
For example, in syntax similar to JSON we could describe the fact that Bob's age is 42 with an object \stt{\{'name' : 'Bob', 'age' : 42\}}.
As triples, we represent Bob being 42 years old with two triples, for example, \stt{[152 'name' 'Bob']} and \stt{[152 'age' 42]}.
As a graph, this would look like the following:

\begin{figure}[H]
  \caption{Information about Bob in graph form}
  \label{fig:bob-as-a-graph}
     \includegraphics[scale=0.15]{bob-age-42.jpg}
  \centering
\end{figure}

You might wonder where the 152 in the triples came from, or for that matter, why the fact that Bob being age 42 couldn't
simply be represented by the single triple \stt{['Bob' 'age' 42]}.
The answer is that you could represent this fact with that one triple, but in doing so you are using \stt{'Bob'} as a key
which might not be that good if your database has more than one Bob in it.
So instead, to prepare for the more general case, Datalog-like graph databases use unique integers to refer to entities.
152 here is like a primary key in relational DB, or an IRI for a particular entity defined in RDF.
A complete RADmapper program for querying the Bob database for people age 42 is as follows:

\begin{figure}[H]
  \caption{A complete query}
  \label{code:bob-age}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
 ( $myDB := [{'name' : 'Bob', 'age' : 42}];
   $ageQuery := query(){[?e :age 42]};
   $result := $ageQuery($myDB); )
\end{lstlisting}
\end{figure} \vspace{-2em}

The above needs some explanation.
On Line 1 we put a JSON-like object in an Javascript-like array by wrapping it in square brackets; this is the literal form of a very small database.
On Line 2 we defined the query function; here note the use of a \textit{query variable} \stt{?e}.
Also note that whereas we used the string \stt{'age'} for the relation, we used \stt{:age} --- syntax we call an \textit{attribute} --- to represent that same relation in the pattern.
On Line 3 we apply the query function \stt{\$ageQuery} to the database \stt{\$myDB} defined on Line 1.
Of course, \stt{\$myDB} isn't much of a database; it contains only the data shown in Figure~\ref{fig:bob-as-a-graph}.
Alternatively, you could have defined data through other means, such as reference to a file or a GraphQL query.
The result of this query, assigned to \stt{\$result} is a \textit{binding set}, a set of objects each describing a consistent binding of the search pattern's variables to values from the database.
In this example, with the data in Figure~\ref{fig:bob-as-a-graph}, the binding set consists of just one binding element and it binds one variable; the binding set is \stt{[\{?e : 152\}]}.
This indicates that the entity indexed at 152 has an attribute \stt{:age} with value 42.
If there were more entities in the database possessing an \stt{:age} attribute, the query would have returned one such \stt{\{?e : <whatever>\}}
binding object for each of them.

Amazing as that query might seem, running against a database with one entity in it and all, it didn't tell us \textit{what person} is age 42.
All we got was a binding set for every entity that has an age attribute equal to 42.
Entity IDs are internal to the database and not of much value to RADmapper users.\footnote{In fact, I sort of told a fib for ease of exposition; by default the binding of variables in the entity position, entity IDs, aren't provided in a binding object.
  Using default settings, what this example returns is \stt{[\{\}]} meaning ``one match was found.''
The binding sets depicted in most examples won't include bindings for entity IDs.}
In order to make any use of this information, we need to join the \stt{[?e :age 42]} pattern with a pattern that grabs the name attribute in the data, \stt{[?e :name ?name]}.
This is shown in Figure~\ref{code:bob-age-more} below.

\begin{figure}[H]
    \caption{A more useful query, getting the name of the 42-year old person}
    \label{code:bob-age-more}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
 ( $myDB := [{'name' : 'Bob', 'age' : 42}];
   $ageQuery := query(){[?e :age 42]
                        [?e :name ?name]}
   $result := $ageQuery($myDB); )
\end{lstlisting}
\end{figure} \vspace{-2em}

The pattern on Line 3, by virtue of its reuse of \stt{?e}, imposes an additional constraint on the graph match: the entity bound to \stt{?e} must have a \stt{:name} attribute.
The value of the name attribute is bound to \stt{?name}.
Thus each element in the binding set will bind two variable, \stt{?e} and \stt{?name}.
The binding set for the database in the graph depicted in Figure~\ref{fig:bob-as-a-graph} is \stt{[\{?e : 152, ?name 'Bob'\}]}.\footnote{If you read the previous footnote you know it actually returns just \stt{[\{?name 'Bob'\}].}}

In this example, we used one variable to match on the entity and another to capture a value, however each position (entity, attribute, and value) can take a variable.
Further, you can use variables in more than one of those positions.
For example, \stt{query()\{[?entity ?attr ?val]\}} is a query that matches on every entity, attribute, and value of the database; it represents every edge of the database's graph.
\stt{query\{[\_ ?attr \_]\}} would return the names of all the attributes in the database (without duplicates). % ToDo: Fix this in the code!
This provides a kind of introspection that is typically more difficult to obtain in other database technology.
When matching the value position you are doing a relational join, for example, we might match the social security number (SSN) in
some data against a same-valued (but possibly differently named) value in other data.
For example,

% ToDo: Get rid of numbering on this example.
\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
   $relJoinQuery := query(){[$DB1 ?e1 :ssn ?id]
                            [$DB2 ?e2 :id  ?id]}
\end{lstlisting} \vspace{-2em}

You may have noticed that the query above, and one used earlier have four elements in their pattern whereas most of the examples have only three (entity, attribute, and value).
If four elements are provided, the first is the database to which the pattern is applied.
If there is only one database being queried, as we've been doing earlier, you don't need to use four-place patterns.
Let's look at a complete \stt{query} example that uses two databases.

\begin{figure}[H]
    \caption{A query that looks into two databases}
    \label{code:two-database-query}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
( $DBa := [{'email' : 'bob@example.com', 'aAttr' : 'Bob-A-data',   'name' : 'Bob'},
           {'email' : 'alice@alice.org', 'aAttr' : 'Alice-A-data', 'name' : 'Alice'}];
  $DBb := [{'id'    : 'bob@example.com', 'bAttr' : 'Bob-B-data'},
           {'id'    : 'alice@alice.org', 'bAttr' : 'Alice-B-data'}];

  $qFn :=  query(){[$DBa ?e1 :email ?id]
                   [$DBb ?e2 :id    ?id]
                   [$DBa ?e1 :name  ?name]
                   [$DBa ?e1 :aAttr ?aData]
                   [$DBb ?e2 :bAttr ?bData]};

  $bSet := $qFn($DBa, $DBb);  )
\end{lstlisting}
  \end{figure} \vspace{-2em}

  In Figure~\ref{code:two-database-query} Lines 1--4 we define two small databases and assign them to variables \stt{\$DBa} and \stt{\$DBb} respectively. On Lines 6--10 we define the query.
Since both databases use email addresses for customer identification, we can use the \stt{:email} and \stt{:id} attributes to join together information about a customer from the two databases.
That is the purpose of the patterns on Lines 6 and 7; the two patterns use different variables for the entities, \stt{?e1} and \stt{?e2},
because the information is coming from different databases and we don't control entity IDs, but both use \stt{?id} to force
matches on email address.
The remainder of the patterns in the query, Lines 8--10, pick up various information from the two databases.
Line 12 calls the query function bound to \stt{\$bSet} to get the binding sets against the two databases.
Unlike our previous calls to the query function, this one takes two databases as arguments.
The order of the arguments in the call must be the same as the order in which the databases appear in the query statement;
\stt{\$DBa} appears first on Line 6, \stt{\$DBb} appears first on Line 7, so \stt{\$DBa} is the first argument to the call.

The binding set that is produced, the value of \stt{\$bSet}, consists of two binding objects:

\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
[{?id : "bob@example.com", ?name : "Bob",   ?aData : "Bob-A-data",   ?bData : "Bob-B-data"  },
 {?id : "alice@alice.org", ?name : "Alice", ?aData : "Alice-A-data", ?bData : "Alice-B-data"}]
\end{lstlisting} \vspace{-2em}

One small but very significant point before moving on to discuss \stt{express}:
writing queries like \stt{query()\{[?e :age 42] [?e :name ?name]\}} could become rather tedious in the case that you might want to get data about some other age value.
For this reason, the \stt{query} declaration can serve to produce a \textit{higher-order function}, a function that returns (query) functions as values. Figure~\ref{code:higher-order-query} demonstrates the idea.

% ToDo: Should I allow jvars to be the keys of binding sets, and thereby eliminate the need for such things as [?e :age ?age] below?

\begin{figure}[H]
    \caption{Get the names of people ages 42 and 33.}
    \label{code:higher-order-query}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
 ( $myDB := [{'name' : 'Bob',   'age' : 42},
              'name' : 'Alice', 'age' : 33}]

   $ageQueryT := query($age){[?e :age  $age]
                             [?e :age  ?age]
                             [?e :name ?name]}

   $ageQ42    := $ageQueryT(42);
   $ageQ33    := $ageQueryT(33);

   $append($ageQ42($myDB) , $ageQ33($myDB))  )
\end{lstlisting}
\end{figure} \vspace{-2em}

The key difference is that on Line 4, the \stt{query} construct, defines a parameter, \stt{\$age}, using ordinary JSONata-like syntax.
You can define as many parameters as you'd like and they can be used to substitute into any of the pattern positions, entity, attribute, or value.
By convention, if we are to assign a higher-order \stt{query} function to a variable, we end the variable name with a \stt{T} such as shown on Line 4, \stt{\$ageQueryT}.
The T suggests that the variable denotes a \textit{query template}.
Lines 8 and 9 define query functions for querying ages 42 and 33, respectively.
Line 11 uses the JSONata-like builtin \stt{\$append} to combine the two binding sets.
Note that the pattern \stt{[?e :age ?age]} on Line 5 is used get ?age into the binding sets.
The result of running this example is the binding set

\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
  [{?name : 'Bob',   ?age : 42},
   {?name : 'Alice', ?age : 33}].
\end{lstlisting} \vspace{-2em}

\subsection{Constructing  Target Data with express}

Binding sets produced by \stt{query} provide ordinary JSONata-like objects\footnote{Two differences: (1) the keys of binding sets are query variables, and (2) binding sets are flat objects; the values at the keys are not objects themselves though they may be entity IDs (integers). These differences notwithstanding, you can use binding sets as though they are ordinary JSONata-like objects.} that could be used with JSONata built-in functions and operators to produce target structures.
However, the \stt{express} construct provides capabilities beyond those of the JSONata expression language.
This section describes some of those features.

Let's continue with our two-database example.
Lines 1--12 of Figure~\ref{code:two-database-query-express} below are as they were in Figure~\ref{code:two-database-query}.
The binding set assigned to \stt{\$bSet} is
\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
[{?id : "bob@example.com", ?name : "Bob",   ?aData : "Bob-A-data",   ?bData : "Bob-B-data"  },
 {?id : "alice@alice.org", ?name : "Alice", ?aData : "Alice-A-data", ?bData : "Alice-B-data"}].
\end{lstlisting} \vspace{-2em}

Assuming that we'd just like to present the target data as nested objects indexed by the customer's email address, for example:

\begin{lstlisting}[language=JavaScript,numbers=none,basicstyle=\ttfamily\scriptsize]
{"alice@alice.org" {"name"  : "Alice",
                    "aData" : "Alice-A-data",
                    "bData" : "Alice-B-data" },

 "bob@example.com" {"name"  : "Bob",
                    "aData" : "Bob-A-data",
                    "bData" : "Bob-B-data"   }}
\end{lstlisting} \vspace{-2em}

\hspace{-2em} we could use the \stt{express} declaration that begins on Line 14 of Figure~\ref{code:two-database-query-express} to do this.

\begin{figure}[H]
    \caption{Using express with a query that looks into two databases}
    \label{code:two-database-query-express}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
( $DBa := [{'email' : 'bob@example.com', 'aAttr' : 'Bob-A-data',   'name' : 'Bob'},
           {'email' : 'alice@alice.org', 'aAttr' : 'Alice-A-data', 'name' : 'Alice'}];
  $DBb := [{'id'    : 'bob@example.com', 'bAttr' : 'Bob-B-data'},
           {'id'    : 'alice@alice.org', 'bAttr' : 'Alice-B-data'}];

  $qFn := query(){[$DBa ?e1 :email ?id]
                  [$DBb ?e2 :id    ?id]
                  [$DBa ?e1 :name  ?name]
                  [$DBa ?e1 :aAttr ?aData]
                  [$DBb ?e2 :bAttr ?bData]};

  $bSet := $qFn($DBa, $DBb);

  $eFn  := express(){{?id : {'name'  : ?name,
                             'aData' : ?aData,
                             'bData' : ?bData}}};

  $reduce($bSet, $eFn) )
\end{lstlisting}
\end{figure} \vspace{-2em}

\stt{express} is a function-defining construct that, like \stt{query}, is capable of returning express functions when supplied with parameters.
In that sense it is capable of being a higher-order function.
But here on Line 14 we aren't using parameter; the declaration is simply \stt{express()\{...\}}; no parameters imply it isn't a template and can be used directly.
The body of the \stt{express} declaration, the text inside the outer curly brackets, defines the pattern of JSONata-like object structure.
The target data is produced by iterating over the express function bound to \stt{\$eFn} using the elements of the binding set.
Two of the most common ways to iterate over a function in functional languages such as JSONata and RADmapper are map and reduce.
Map and reduce differ in how they process the collection of arguments:
map applies a given function to each element independently;
reduce ``summarizes'' results by allowing each element to affect a summary outcome.\footnote{Examples to help you recall how these work:
  \\ \stt{\$map([1,2,3,4], function(\$x)\{\$x * 2\})} returns [2,4,6,8]; it multiplies each argument by 2.
  \\ \stt{\$reduce([1,2,3,4], function(\$x, \$y)\{\$x + \$y\})} returns 10; it applies \stt{+} to 1 and 2, then to 3 and that sum,
  then to 4 and that sum.}
Whether you \stt{\$map} or \stt{\$reduce} the \stt{express} function over the binding set can have great influence on the outcome, as will be demonstrated in subsequent examples.
As written above, the call to \stt{\$reduce} on Line 18 creates a nested structure for the first binding element and then inserts a second structure into it at the second \stt{?id} key, as shown above.
Were Line 18 replaced with \stt{\$map(\$bSet, \$eFn)}, the result would be two independent nested maps:

\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numbers=none]
[{"bob@example.com" : {"name" : "Bob",   "aData" : "Bob-A-data",  "bData" : "Bob-B-data"  }},
 {"alice@alice.org" : {"name" : "Alice", "aData" : "Alice-A-data","bData" : "Alice-B-data"}}].
\end{lstlisting} \vspace{-2em}

\subsection{Predicate patterns and an example from a different perspective}

This example illustrates (1) simple restructuring of a data structure, (2) use of predicates as query patterns, (3) extensive joining
to navigate deeply nested structures, and (4) use of query variable in the attribute position of patterns.
The example is based on a discussion on the JSONata Slack channel.
The goal of the example is to swap the nesting of \stt{owners} and \stt{systems} as shown in Figure~\ref{data:restruct}.

\begin{figure}[H]
  \caption{The goal is to swap the nesting of 'owners' and 'systems' in the data on Lines 1--9
  so that it looks Lines 13--21.}
 \label{data:restruct}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize]
{ "systems":
   { "system1": { "owners": { "owner1": { "device1": { "id": 100, "status": "Ok" },
                                          "device2": { "id": 200, "status": "Ok" }},
                              "owner2": { "device3": { "id": 300, "status": "Ok" },
                                          "device4": { "id": 400, "status": "Ok" }}}},
     "system2": { "owners": { "owner1": { "device5": { "id": 500, "status": "Ok" },
                                          "device6": { "id": 600, "status": "Ok" }},
                              "owner2": { "device7": { "id": 700, "status": "Ok" },
                                          "device8": { "id": 800, "status": "Ok" }}}}}}

 /* ...so that it looks like: */

{"owners":
   {"owner1": {"systems": {"system1": {"device1": {"id": 100, "status": "Ok"},
                                       "device2": {"id": 200, "status": "Ok"}},
                           "system2": {"device5": {"id": 500, "status": "Ok"},
                                       "device6": {"id": 600, "status": "Ok"}}},
    "owner2": {"systems": {"system1": {"device3": {"id": 300, "status": "Ok"},
                                       "device4": {"id": 400, "status": "Ok"}},
                           "system2": {"device7": {"id": 700, "status": "Ok"},
                                       "device8": {"id": 800, "status": "Ok"}}}}}))))
\end{lstlisting}
\end{figure}

Though these structures, rendered as JSON, may look odd (for example, there are no arrays used despite apparent value in having them\footnote{For example, several devices are associated with an owner, but instead of arrays, the developer used meaningful names as keys, "device1","device2" etc. Perhaps these structures only seems unusual if your perspective involves the object/attribute/value patterns that are typical of messaging structures.}) this is not relevant to the discussion.
Typical of a restructuring task, the goal data on Lines 13--21 does not contradict any of the facts evident in the original data on Lines 1--9.
For example, there is an owner called \stt{owner1}, and \stt{owner1} still has the same devices associated.
The idea that mapping is about how facts are viewed is a key concept in RADmapper.
What has changed in restructuring the example data is not a fact but the kind of forward navigation that is possible in the two structures.
In the original structure, it is possible to navigate forward from a system to an owner (such as on Line 1, from \stt{system1} to \stt{owner1}).
In the restructured data, it is possible only to navigate forward from owner to system (such as \stt{owner1} to \stt{system1} on Line 14).
The restructuring task can be achieved using only JSONata functions and operators as depicted in Figure~\ref{code:jsonata-sTPDRs}.

% Note how I use escapeinside here, to replace tilde with `$\sim$'.
\begin{figure}[H]
\caption{Using JSONata to restructure the data.}
 \label{code:jsonata-sTPDRs}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize,escapeinside=`']
{
    "owners": $distinct(systems.*.owners.$each(function($d, $ownerName) {$ownerName}))@$o.{
      $o: $each($$.systems, function($sys, $sysName) {{$sysName: $lookup($$.systems, $sysName).owners `$\sim$'> $lookup($o)
      }}) `$\sim$'> $merge()
    } `$\sim$'> $merge()
}
\end{lstlisting}
\end{figure} \vspace{-2em}

Though the RADmapper solution to this problems involves more lines of code (see Figure~\ref{code:restruct} below), it is arguably easier to understand.
The RADmapper solution is also arguably a better candidate for \textit{interoperable} exchange of mappings, as will be discussed later.

\begin{figure}[H]
  \caption{RADmapper \stt{query} and \stt{express} used to restructure data.
    Note that on Line 15 we use \stt{express} in-lined rather than assigning that function to a variable and passing the variable into \stt{\$reduce}. The choice to in-line has no effect on the result.}
 \label{code:restruct}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize]
  (   $data := $read('data/testing/jsonata/sTPDRs--6.json');
         $q := query(){ [?s ?systemName ?x]
                        [($match(?systemName, /system\d/))]
                        [?x :owners ?y]
                        [?y ?ownerName ?z]
                        [($match(?ownerName, /owner\d/))]
                        [?z ?deviceName ?d]
                        [($match(?deviceName, /device\d/))]
                        [?d :id ?id]
                        [?d :status ?status] };

     $bsets := $q($data);

     $reduce($bsets,
             express() {  {'owners':
                             {?ownerName:
                               {'systems':
                                  {?systemName:
                                     {?deviceName : {'id'     : ?id,
                                                     'status' : ?status}}}}}}
                        }
            )
  )
\end{lstlisting}
\end{figure} \vspace{-2em}

Where this example differs from earlier ones is the use of \stt{\$match} on Lines 3, 6 and 8.
Instead of the usual 3- or 4-place pattern, we have a single \textit{predicate} that is being applied using query variables from other patterns in the query.
\stt{\$match} is a JSONata built-in Boolean function that returns true if the first argument, a string, matches the second argument, a regular expression.
%An introduction to the \stt{query} construct defined on Lines 2--10 of Figure~\ref{code:restruct} is provided in the following paragraphs with the help of Figure~\ref{fig:hairpin}.
This example is also the first to use extensive joins to navigate into deeply nested objects.
A ``hairpin'' pattern of joined variables is depicted in Figure~\ref{fig:hairpin} and reflected in Lines 2--10 of Figure~\ref{code:restruct}.

\begin{figure}[H]
  \caption{Part (a): navigation of the source structure (Lines 1--9 of the data in Figure~\ref{data:restruct}).
    Part (b): graph and triples representing device1.
    The circled numbers refer to lines in the code of Figure~\ref{code:restruct}.}\label{fig:hairpin}
   \includegraphics[scale=0.15]{hairpin-two-part.jpg}
  \centering
\end{figure}

A Datalog database can be viewed as several index tables about the triples (such as those depicted in Figure~\ref{fig:hairpin} (b).)
One such index table will index primarily by entity, another primarily by attribute, etc.
Some of Lines 2--10 in Figure~\ref{code:restruct}, for example, Line 2, \stt{[?s ?systemName ?x]}, have the form of these triples, where respectively \stt{?s}, \stt{?systemName} and \stt{?x} match an entity, attribute, and value.
Line 4, \stt{[?x :owners ?y]}, is similar but the attribute position is occupied by \stt{:owners}.
This triple will match any fact that has the string \stt{"owners"} in its attribute position.
There are two such facts in the data depicted in Figure~\ref{data:restruct}, one on Line 2, and one on Line 6.
In both cases the value position is occupied by another entity reference.
Figure~\ref{fig:hairpin}(b) similarly depicts a triple whose value position references another entity, \stt{[203, device1, 204]}.

Lines 3, 6 and 8 of the query do not use the 3-place triple pattern; they consist of a single JSONata expression wrapped in parentheses.
The expression should be a Boolean (should return true or false).
 Note that the expression uses variable bindings (e.g \stt{?systemName}, \stt{?ownerName}, and \stt{?deviceName}) used in triples of the query.
 \stt{/system\textbackslash d/} is a JavaScript regular expression matching a string containing \stt{"system"} followed by a single digit (the \stt{\textbackslash d} part).
The following paragraph provides a line-by-line summary of how the query in Lines 2--10 works.

\begin{description}
\item[Line 2 \stt{[?s ?systemName ?x]}:] All positions of this triple pattern are occupied by variables, so by itself it would match every triple in the database.
\item[Line 3 \stt{[(\$match(?systemName, /system\textbackslash d/))]}:] This uses the query variable \stt{?systemName} bound to the entity position on Line 2.
  Therefore, between this pattern and the one in Line2, the only triples matching both of these patterns have ``system1'' or ``system2'' in the attribute position. (See the data to verify this.)
  \stt{?s} and \stt{?x} from Line 2 are thus bound to the entity and value positions of triples having either ``system1'' or ``system2'' in their attribute positions.
\item[Line 4 \stt{[?x :owners ?y]}:] Here we see \stt{?x}, which was introduced in Line 2, reused in the entity position.
  We know that \stt{?x} is bound to an entity by looking at the data.
  (See Line 2 in the data for example, \stt{ ``owners'': \{\ldots}. The ``\stt{: \{}'' means the thing keyed by ``owners'' here is a JSON object (an ``entity'' in the database).
  This triple pattern ensures that \stt{?x} refers to entities for with the "owners" occupies the attribute position.
\item[Line 5 \stt{[?y ?ownerName ?z]}:]  Like Line 2, this is used to introduce an new variable, \stt{?ownerName} in this case, which will be used in the a \stt{\$match} predicate similar to Line 3.
  One difference here, however, is that the value of \stt{?y} is constrained by the triple pattern on Line 4.
\item[Line 6 \stt{[(\$match(?ownerName, /owner\textbackslash d/))]}:] This serves a similar purpose Line 3, but for owner keys.
\item[Line 7 \stt{[?z ?deviceName ?d]}:] This is like Lines 1 and 5, introducting a new variable for use in the \stt{\$match}.
  Like Line 5, the value of the variable in entity position is constrained by another pattern.
\item[Line 8 \stt{[(\$match(?deviceName, /device\textbackslash d/))]}:] This is similar in purpose to the other two uses of \stt{\$match}.
\item[Line 9 \stt{[?d :id ?id]}:] Here we are finally ready to pick up some user data, the value of a device's ``id'' attribute.
\item[Line 10 \stt{[?d :status ?id]}:] Like Line 9, but to pick up the value of a device's ``status'' attribute.
\end{description}

% Discuss use of key() and vector syntax to create more conventional output.
It was suggested earlier that the encoding of the source data was a bit unusual.
For example, object key values such as \stt{owner1}, \stt{system1} and \stt{device1} are being used, apparently, both to indicate a unique entity and to identify the kind of entity being described, presumably an owner, system and device respectively.
We might seek target data that explicitly declares the type and identifier separated, for example using attributes \stt{type} and \stt{id} respectively.
The target data sought, for example, might be as depicted in Figure~\ref{data:slack-with-keys}.

\begin{figure}[H]
  \caption{An alternative organization of the target data from the example.}
 \label{data:slack-with-keys}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize]
[{"type"   : "OWNER",
  "id"     : "owner1",
  "systems": [{"type"   : "SYSTEM",
               "id"     : "system1",
               "devices": [{"type"   : "DEVICE",
                            "id"     : "100",
                            "status" : "Ok"},
                           {"type"   : "DEVICE",
                             "id"    : "200",
                             "status": "Ok"}]},
              {"type"   : "SYSTEM",
               "id"     : "system2",
               "devices": [{"type"   : "DEVICE",
                            "id"     : "500",
                            "status" : "Ok"},
                           {"type"   : "DEVICE",
                             "id"    : "600",
                             "status": "Ok"}]}]},
 {"type"   : "OWNER",
  "id"     : "owner2",
  "systems": [{"type"   : "SYSTEM",
               "id"     : "system1",
               "devices": [{"type"   : "DEVICE",
                            "id"     : "300",
                            "status" : "Ok"},
                           {"type"   : "DEVICE",
                             "id"    : "400",
                             "status": "Ok"}]},
              {"type"   : "SYSTEM",
               "id"     : "system2",
               "devices": [{"type"   : "DEVICE",
                            "id"     : "700",
                            "status" : "Ok"},
                           {"type"   : "DEVICE",
                             "id"    : "800",
                             "status": "Ok"}]}]}]
\end{lstlisting}
\end{figure}  \vspace{-2em}

As the figure depicts, the output is more verbose. % , and only in Hollywood do the colons line up in the columns like that
A guess at an \stt{express} structure to produce this output is as follows.
\begin{figure}[H]
  \caption{Draft express structure for target data as depicted in Figure~\ref{data:slack-with-keys}}
 \label{code:slack-possible-express}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize]
$ex1 := express{{'type'   : 'OWNER',
                 'id'     : ?ownerName,
                 'systems': [{'type'   : 'SYSTEM',
                              'id'     : ?systemName,
                              'devices': [{'type'  : 'DEVICE',
                                           'id'    : ?deviceName,
                                           'status': ?status}]}]}
               }
\end{lstlisting}
\end{figure}  \vspace{-2em}

If we were to map over that \stt{express} body, that is \stt{\$map(\$bsets,\$ex1)}, the result would be (logically correct, of course but) even more verbose and also repetitive because there will be one full structure like the \stt{express} body for each of the 8 binding sets.
A better alternative might be to \stt{\$reduce} over the \stt{express}, that is, \stt{\$reduce(\$bsets,\$ex1)};
\stt{\$reduce} can have the effect of ``summarizing'' data, in this case by squeezing out the repetition.
However, there is a problem with reducing over the \stt{express} body as written;
it would produce the following:

\begin{figure}[H]
  \caption{Reducing over the \stt{express} body here results in iteratively overwriting data, so that the result is
    the same as applying \stt{express} body to just the last binding set.}
 \label{code:slack-result-wo-keys}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize]
{"type"    : "OWNER",
 "id"      : "owner1",
 "systems" : {"type"    : "SYSTEM",
              "id"      : "system1",
              "devices" : {"type"   : "DEVICE",
                           "id"     : "device2",
                           "status" : "Ok"}}}

   /* This result indicates that the last binding set processed was the following */
   {?ownerName : "owner1", ?systemName : "system1", ?deviceName : "device2", ?status : "Ok", ?id : 200}
\end{lstlisting}
\end{figure}  \vspace{-2em}

What happened to the rest of the data?
Why were data not lost similarly when we reduced over the \stt{express} body on Lines 14--20 of Figure~\ref{code:restruct}?
The answer is that the \stt{express} body of Figure~\ref{code:restruct} uses unique values for the object keys.
The effect of reducing over the \stt{express} body in that example is to ``drop in'' new pathways for each binding set.
Specifically, if we consider the Lines 13--21 of Figure~\ref{data:restruct}, the result of applying the \stt{express} body on Lines 14--20 of Figure~\ref{code:restruct} to the key values in  each corresponding binding set, it is apparent that:

\begin{itemize}
\item the Line 14 object was created by the keys \stt{"owners"}, \stt{"owners1"}, \stt{"system1"}, \stt{"device1"},
\item the Line 15 object was created by the keys \stt{"owners"}, \stt{"owners1"}, \stt{"system1"}, \stt{"device2"},
\item the Line 16 object was created by the keys \stt{"owners"}, \stt{"owners1"}, \stt{"system2"}, \stt{"device5"}, and
\item et cetera, to Line 21, created by the keys \stt{"owners"}, \stt{"owners2"}, \stt{"system2"}, \stt{"device8"}.
\end{itemize}

There are then 3 solutions to the problem just highlighted:
(1) use unique keys  to ``drop in'' new pathways like in the original example,
(2) use \stt{\$map} instead of \stt{\$reduce}, which entails accepting the fact that the result will be verbose with lots of repetition, or
(3) wrap keys in the \stt{key} construct as described below.

\subsubsection{The key construct of express}

We'll continue with the running example.
In order to prevent the overwriting that was depicted in Figure~\ref{code:slack-result-wo-keys} we will
adapt the code from Figure~\ref{code:slack-possible-express} by adding the \stt{key} construct as shown.

\begin{figure}[H]
  \caption{The express structure from Figure~\ref{code:slack-possible-express} revised to identify keys}
 \label{code:slack-express-with-keys}
\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize,numberstyle=\scriptsize]
$ex1 := express{{'owners' : {'type'    : 'OWNER',
                              'id'     : key(?ownerName),
                              'systems': [{'type'   : 'SYSTEM',
                                           'id'     : key(?systemName),
                                           'devices': [{'type'  : 'DEVICE',
                                                        'id'    : key(?deviceName),
                                                        'status': ?status}]}]
                            }
                  }
                 }
\end{lstlisting}
\end{figure}  \vspace{-2em}

There are two significant modification to the orginal \stt{express} body.
First, Lines 2, 4, and 6 wrap the respective binding variables \stt{?ownerName}, \stt{?systemName}, and \stt{?deviceName} in
the \stt{key} construct to declare identity conditions for the corresponding objects.
This will ensure that binding sets on paths with those keys insert new data, not overwrite existing data.
Second, compared to the orginal code, the whole body is now wrapped in \stt{\{'owners ...\}}.
This ensures that calls to reduce have a common root on which to grow the structure.

Incidentally, the situation that we just handled is similar to the choice between updating and inserting data.
When we declare a field a key, we are saying that other values for that field necessarily refer to other conceptual objects,
and therefore the data should be inserted, not used to update the existing object.

\subsection{Summary so far}

% Now discuss the idea of playing with challenging problems in the exerciser, ***starting with simple queries***, and getting bsets
% before reformatting with express. (Compares favorably to JSONata.)
% Use this to segue to a discussion of using an exerciser to validate mapping requirements,
% then using the AST strategy to map to other forms (e.g. to validate with stakeholders, map to a commercial mapping language,
% joint cognitive work, etc.

\subsection{Don't bother to read past here.}

\subsection{Interoperability?}

\textbf{[Discuss simple examples of using ASTs and mapping to "mapping tables". 90 percent of use cases don't need this.]}

% Standards encode industry consensus on best practice.
% It would be presumptuous of us to suggest that we've captured the essence of the vaguely defined task sometimes referred to as "mapping", or "data "restructuring" -- much less industry consensus on the best practice for it.
% The usual methods of promulgating standardization through a domain-specific language might not work here.
% Nonetheless, we might be able to chip away at the walls of task and discipline isolation through other means.
% We suggest that these other means entail using the RADmapper language as describe above to do requirements engineering,
% and then mapping the expression of the requirements to other forms.
% THIS NEEDS WORK!
% One challenge to doing this that by using the RADmapper syntax we've locked the requirements in a domain-specific programming language
% that possess the sort of concision that appeals to programmers; RADmapper syntax is more a language for requirements validation
% than it is for expression of requirements.

\subsection{Section Summary and Additional Thoughts}

RADmapper's \stt{query} is based on Datalog, a language which was studied extensively in the 1980s \cite{Abiteboul1995a}
and has influenced languages such as SPARQL and the Shapes Constraint Language (SHACL) \cite{?}.
\stt{query} has the power of SQL's  query but does operates fact-at-a-time versus SQL's entity-at-a-time.
That distinction entails, for example concerning the previous example, that in Datalog the facts (1) "\stt{device1} \stt{id} is \stt{100}." and (2) "\stt{device1} \stt{status} is \stt{Ok}." are independent assertions that happen to be about the same entity, \stt{device1}.
In contrast, SQL's entity-at-a-time design entails that there is a table about devices and the table row at primary key \stt{device1} has information about both \stt{id} and \stt{status}.
There are advantages and disadvantages to both Datalog and SQL.\@
For example, it should be apparent that pulling together all the information about an entity with Datalog queries requires relational joins, one each for each fact.
On the other hand, RADmapper can learn Datalog-like schema by studying the data, it can create databases in milliseconds, and adding new attributes (columns in SQL) does not require data migration in Datalog.

The order of the patterns in a \stt{query} statement does not matter at all; it does not matter with respect to the execution speed nor the result produced.
However, in order to illustrate the chaining of joins being performed, it is useful to the readers of your code to keep joined things together.
This is illustrated, for example, by the curvy red line in Figure~\ref{fig:hairpin}(a).


%\footnote{What  additional atomic data
%  types shall we provide? Dates? URIs? UUIDs? etc.}%~\footnote{Triples provide 5th-normal form relational data. Recomposing a concept from 5-th normal form typically requires as many joins as
%  there are attributes to recompose.
%  The upside of using triples are that
%  (1) substantial amounts of data are already in triples (e.g. RDF etc.),
%  (2) some query engines helpfully index triples in multiple ways entity-attribute-value, attribute-entity-value, and attribute-value-entity, and
%  (3) mapping engines can use triples effectively.
%  The challenge in using triples with this language is in preserving the abstraction of a functional pipeline owed to JSONata-like language features.}

%%The graph-based viewpoint on such data is that $x$ and $y$ are vertices, and $rel$ is an edge.
%%$rel$ might be implemented as a string.
%%
%%
%%
%%Thus, the translation of structured data such as JSON objects into such triples is relatively straightforward:
%%\begin{enumerate}
%%\item A unique entity identifier is associated with each object; this identifier serves as the first element of triples about that object.
%%      In JSON, for example, an object is a collection of name-value pairs delimited by curly brackets.
%%    \item Each object attribute is represented by the string naming it;%\footnote{I suppose we'll only support strings, though namespaced %%symbols would be nice!}
%%      these supply the second element of the triple, the $rel$.
%%\item The third element of the triple provides an atomic datum (string, number, entity identifier, etc.) associated with the subject attribute %%of the subject object.
%%\end{enumerate}
%%
%%For example, the first object in Figure~\ref{code:simple}, \stt{\{"ShipDate":  "2021-06-15", "Item":  "Widget 123", "Qty": 1.0, "UnitPrice": %%10.5\}} can be encoded as
%%the following four triples, where the integer 11 is the unique entity identifier for this object.
%%
%%\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize]
%% [11, "ShipDate",  "2021-06-15"]
%% [11, "Item",  "Widget 123"]
%% [11, "Qty", 1.0,]
%% [11, "UnitPrice", 10.5]
%%\end{lstlisting}
%%
%%Of course, an object can have multiple values for an attribute.
%%For example, a person can have multiple phone numbers.
%%The way you'd typically handle cardinality greater than 1 in JSON and similar schemes is to simply provide the attribute with an array value.
%%For example,
%%
%%\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize]
%% {"name" : "Bob", "phoneNumbers" : ["123-456-1111", "123-456-2222"]}
%%\end{lstlisting}
%%
%%In these cases, there would be a triple for each of phone numbers.
%%Thus, the above might be normalized to triples as follows:
%%
%%\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize]
%% [12, "name" "Bob"]
%% [12, "phoneNumbers" "123-456-1111"]
%% [12, "phoneNumbers" "123-456-2222"]
%%\end{lstlisting}
%%
%%In the following, an array of objects is used for phone numbers.
%%Consequently, the \stt{PhoneNumberObjs} triples on entity 13 reference additional entities, not data.
%%
%%% This is kind of a screwed up example. There should be {phone/type: "cell", phone/num: "123-455-3424"}
%%\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize]
%%{"name" : "Bob", "phoneNumberObjs" : [{"cell" : "123-456-1111"}, {"work" : "123-456-2222"}]}
%%\end{lstlisting}
%%
%%\begin{figure}[H]
%%  \caption{The object for Bob as triples}
%%  \label{code:bob-phone}
%%%\lstset{numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true}
%%\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
%% [13, "name" "Bob"]
%% [13, "phoneNumberObjs" 14]
%% [13, "phoneNumberObjs" 15]
%% [14, "cell" "123-456-1111"]
%% [15, "work" "123-456-2222"].
%%\end{lstlisting}
%%\end{figure}
%%
%%It is worth taking the time to get comfortable with this idea of encoding information in triples;
%%it is how we work with complex data in RADmapper.
%%
%%
%%\subsection{Queries on Triples}
%%You can query triples using Datalog-like notation.\footnote{There are many implementations of Datalog, includes ones for Java and JavaScript, %%so what is being proposed here should not be hard to implement.} Queries have a square-bracket notation similar to triples illustrated above, %%but with \textit{query variables} substituted for some of the values.
%%In JSONata, variables start with a \stt{\$}, in queries, query variables start with a \stt{?}.
%%For example, \stt{[?e "name" "Bob"]} is a query that will bind the query variable \stt{?e} to the entity identifier of any entity that has %%"Bob" as its \stt{name} attribute.
%%But why would you want the entity identifier, it isn't domain data?
%%The typical answer is that you will need it to perform a sort of join on triples.
%%For example, if we want to get the \stt{cell} number for \stt{Bob}, we could use the following interrelation of triples.
%%
%%\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize]
%% [?e "name" "Bob"]
%% [?e "phoneNumberObj" ?pn]
%% [?pn "cell" ?cellNum]
%%\end{lstlisting}
%%
%%If the triples queried are just the ones of Figure~\ref{code:bob-phone}, then the triple on Line 1 matches the query pattern \stt{[?e "name" %%"Bob"]}, binding \stt{?e} to the entity id 13.
%%The second query pattern, \stt{[?e "phoneNumberObjs" ?pn]}, matches two triples, those on Lines 2 and 3, binding \stt{?pn} to either entity 14 %%or 15.
%%Owing to specifying \stt{"cell"} as the attribute, however, the third query pattern, \stt{[?pn "cell" ?cellNum]}, only matches the triple on %%Line 4.
%%This result could be expressed in a JSON-like object notation as a collection of objects such as:
%%\stt{[\{?e: 13, ?pn: 14, ?cellNum: "123-456-1111"\}]}.
%%Each such collection of bindings values that together consistently match the query variables in the data is called a \textit{binding set}.
%%Note that binding sets can contain the database entity IDs, for example, binding \stt{?e} to entity 13 and \stt{?pn} to entity 14 in the above.
%%Though entity IDs are not part of the domain data, they are part of how data is strung together by the triples and thereby they might be %%useful.
%%%For example, the collection of query triples \stt{[?e "name" "Bob"]}, \stt{[?e "phoneNumberObjs" ?pn]}, and
%%%\stt{[?pn "cell" ?cellNum]} used above could match against various entities where there is an entity whose \stt{name} attribute
%has value "Bob", that entity has a \stt{phoneNumberObj} attribute, and the \stt{?pn} value matches an entity that
%has a \stt{cell} attribute. Each of the binding sets produced would specify values for the three variables \stt{?e}, \stt{?pn} and %\stt{?cellNum}.
%%Figure~\ref{code:simple-binding-set} depicts another example, the generation of two binding sets from in-line data.
%%
%%\begin{figure}[H]
%%  \caption{A simple query against in-line data.}
%%  \label{code:simple-binding-set}
%%\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
%%  ( $ := [{'Person/firstname' : 'Bob'  , 'Person/lastname' : 'Clark'},
%%          {'Person/firstname' : 'Peter', 'Person/lastname' : 'Dee'}];
%%    $.query([?person :Person/firstname ?fname]
%%             [?person :Person/lastname  ?lname]) )
%%
%%   /* Returns the following binding set: */
%%   [{:person 4, :fname 'Peter', :lname 'Dee'}
%%    {:person 3, :fname 'Bob', :lname 'Clark'}]
%%\end{lstlisting}
%%\end{figure}
%%
%%There are a few thing to note about working with Datalog-like languages like this one.
%%First, except for performance concerns, it does not matter what order you list the query triples.
%%Second, you can put query variables in any (or all) of the three positions.
%%For example, \stt{[?e "cell" "123-456-1111"]} binds \stt{?e} to 14 in the above.
%%Third, it is possible that there is in the data more than one match;
%%for example, \stt{[?e ?a ?v]} returns a collection binding set matching all data that is in context.
%%%It is possible, using query parameters not yet discussed, to limit what is return to the first match, etc.
%%Finally, you can imagine that using attribute names like "name" and "qty" could get confusing. (Name of what? Quantity of what?)
%%For this reason, where possible, best practice in Datalog-like languages uses namespaced attributes.
%%We could use, for example, strings with a slash between the namespace name and the property name.
%%Thus perhaps, \stt{"Person/name"} and \stt{"Phone/cell"}.
%%But since these identifiers serve the special purpose of \textit{attributes}, the language uses a special syntax: a prefixed colon rather than %%string delimiters.
%%Thus \stt{:Person/name} and \stt{:Phone/cell}.
%%%Where it helps reduce mistakes and the cognitive load on programmers, getting data in that form can be done with JSONata-like pre-processing.
%%Figure \ref{code:simple-binding-set} above illustrates use of the attribute syntax on Lines 3 and 4.
%%
%%\subsection{Query Functions}
%%%We can now propose a language feature for querying data using the Datalog-like syntax.\footnote{Soon, we will need to demonstrate how this %%(and the \stt{express} and
%%%  \stt{transform} language features discussed below) solve problems that are hard to address with strictly JSONata-like capabilities.
%%%  I'll implement these features and create a Docker web app we can use to play with them. In the mean time, test cases from stakeholders are %%%\textbf{greatly appreciated!}}
%%
%%\stt{query} is a RADmapper language element that takes a collection of triple forms and (optional) parameters and returns a function that, %%when applied to data, returns a collection of binding sets.
%%For example:
%%
%%\begin{lstlisting}[language=JavaScript]
%% $.query([?e "name" "Bob"]
%%         [?e "phoneNumberObjs" ?pn]
%%         [?pn "cell" ?cellNum])
%%\end{lstlisting}
%%
%%returns \stt{[\{?e: 13, ?pn: 14, ?cellNum: "123-456-1111"\}]} when \stt{\$} is the data of Figure~\ref{code:bob-phone}.
%%The example below illustrates the use of an optional parameter \stt{\$name}:
%%
%%\begin{lstlisting}[language=JavaScript]
%% queryCellByName := query($name)([?e "name" $name]
%%                                 [?e "phoneNumberObjs" ?pn]
%%                                 [?pn "cell" ?cellNum])
%%\end{lstlisting}
%%
%%Using the same data, \stt{\$.queryCellByName("Bob")} would return the same result as the previous query, where "Bob" is hard-coded.
%%
%%
%%%\subsection{Simple Restructuring}
%%
% Commented stuff belongs elsewhere.
% As mentioned earlier, A Datalog database can be viewed as four tables supporting a collection of triples.
%The indexes could be viewed as tables of the entity, attribute, and value entries, each with different primary keys. Thus...




%\subsection{Vectors and Iteration}
%
%\subsubsection{Mapping Over a Vector}
%% POD "array" or "collection"?
%In the language, iteration is typically performed implicitly in the sense that when the argument to an operation is an array, the operation is applied to each element of the collection.
%The result returned is an array of the result of applying the operator to each element.
%Thus in Figure~\ref{code:simple-map}, \stt{.zipcode} is applied to the array \stt{\$ADDRS} returning  an array \stt{[``20898'' ``07010-35445'', ``10878'']}.
%
%% https://tex.stackexchange.com/questions/336919/simple-coloring-of-json-attributes
%\lstset{
%%    string=[s]{"}{"},
%%    stringstyle=\color{blue},
%%    comment=[l]{:},
%%    commentstyle=\color{black},
%    basicstyle=\footnotesize\ttfamily
%  }
%
%  % M-x eval-expression (local-unset-key "\"") to work on this! (avoids ``...'').
%\begin{figure}[H]
%\caption{Map over an array of entities, collecting ZIP code.}
% \label{code:simple-map}
%\begin{lstlisting}[language=JavaScript,basicstyle=\ttfamily\scriptsize]
%
%(
%  $ADDRS :=
%     [{"name"     : "Peter",
%       "street"   : "123 Mockingbird Lane",
%       "zipcode"  : "20898"},
%
%       {"name"    : "Bill",
%        "street"  : "23 Main Street",
%        "zipcode" : "07010-3545"},
%
%       {"name"    : "Lisa",
%        "street"  : "903 Forest Road",
%        "zipcode" : "10878"}];
%
%   $ADDRS.zipcode
%)
%
%\end{lstlisting}
%\end{figure}
%
%% I checked: This is what JSONata does too!
%  In the case that the operator returns null for elements of the array, no value is collected.
%  For example, if ``Bill'' in the above didn't have a zipcode, \stt{\$ADDRS.zipcode} would have returned \stt{["20898", "10878"]}.
%
%\subsubsection{Filtering  an Array}
%Suppose, for some odd reason, we didn't like 9-digit Zip codes (what the US Postal Service calls ``Zip+4'') and that we simply want to exclude them from the collection.
%There are a few simple ways to do this.
%One of those is to append a test expression to the end of the previous expression. This ``filtering'' test expression needs to be enclosed in square brackets to indicate that it is filtering.
%\stt{\$ADDRS.zipcode[\$match(/\^{}\textbackslash d[5,5]\$/)]}. Regular expression syntax is arcane but what is shown is typical of JavaScript, Java and many other regex libraries.
%The above matches on strings that are exactly 5 number characters, thus excluding the Zip+4 Zip Codes.
%
%\subsubsection{Index Variables} % Move this to "Challenge problems"???
%Index variables are variables used to iterate through arrays.
%They are common in procedural code, for example, the variable \stt{i} in the pseudocode \stt{for i in [1..9] \{\ldots \}} is an index variable..
%A goal of interoperable exchange is to allow the expression of individual mapping statements that can be defined independent of larger program context.
%This kind of independence is useful in conventional \textit{mapping tables}, spreadsheet used to describe to programmers the intent of proposed mapping.
%The problem with index variables in this regard is that they would add meandering procedural expression where concise, independent, declarative expression is desired.
%%This is why the functional programming features known as \textit{map}, \textit{filter}, and \textit{reduce} are used.
%But what if you needed to enumerate the things you were working with, for example, to put an index number in front of them?
%In cases like this, you can avoid the need for an index variable by using the language's \stt{\$map} higher-order function; it is like JavaScript's \stt{map}.
%See Figure~\ref{code:index-in-map} below.
%
%\begin{figure}[H]
%    \caption{Using an index variable.}
%    \label{code:index-in-map}
%\vspace{3mm}
%    \stt{\$map(\$ADDRS.zipcode, function(\$v, \$i) \{'zip ' \& (\$i+1) \& ' ' \& \$v\})}\\
%\vspace{3mm}
%returns \\
% \stt{[ 'zip 1 20898', 'zip 2 07010-3545', 'zip 3 10878']}.
%\end{figure}
%
%In the above, \stt{function} introduces a function, and the following code in brackets is the body of the function, a single expression is returned.
%In \stt{\$map} (and \stt{\$filter}, and \stt{\$reduce} described later), the function is called once each with each member of the first argument (\stt{\$ADDRS.zipcode} here) in sequence
%as the value bound to \stt{\$v}, and \stt{\$i} is bound in turn to successive integers in the sequence \stt{[1,2,3]}.
%This effectively eliminates the need for user-defined index variables.
%
%\subsection{Working with Code Lists}
%
%A mapping tasks commonly needed is translating a code list, or subsetting one to a set of code values that actually is used in your business processes.
%For example, there is a very large set of codes for transportation events in the code list \textbf{[don't recall the spec]}.
%Suppose you are receiving messages with lots of these values but your order management application only wants to know whether the shipment is likely to be late.
%There is no getting around the fact that you need to explicitly describe a functional relationship to do this; the functional relationship can be implemented as a lookup table.
%The language defines a switch statement to do this kind of thing.
%An example is shown in Figure~\ref{code:mapping-codes}.
%
%\begin{figure}[H]
%    \caption{Mapping code values.}
%    \label{code:mapping-codes}
%%\lstset{frame=tb,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true}
%\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
%  $Codes2OurCodes := function($theirs)
%   {switch $theirs {
%       #{2, 5, 52, 66} : 'late';
%       #{3, 6, 77, 85} : 'on time';
%       * : 'unknown'}
%   };
%\end{lstlisting}
%\end{figure}
%
%The code in Lines 3 and 4 of Figure~\ref{code:mapping-codes} implement a table.
%The \#\{\ldots\} syntax defines sets.
%On Line 3 the source defines set of code values (2, 5, 52, and 66) and its use indicates that elements of this set are mapped to the target value ``late''.
%
%Were the table to be larger, writing it could get tedious.
%For this reason, it might be reasonable to provide an alternative, whereby a lookup table provided elsewhere is referenced.\footnote{The code in Figure~\ref{code:mapping-codes} also
%  shows how names are associated with functions.
%  Functions in the language do not have names.
%  If you need to use a function in multiple places, assign it to a variable as shown in the figure, (use of \stt{\$Codes2OurCodes}).}

\subsection{Working with Tabular Data}

Being able to read  and write spreadsheet information is a very handy capability in mapping.
Of course, Excel-like spreadsheets can have multiple sheets and the content can be non-uniform, including merged cells and formula.
The language currently does not provide means to deal with these complexities.
However simple tables with no surprises and a header row naming columns (and common-separated value (CSV) files that conform to these requirements) can easily be viewed as an array of map structures.
For example, Table~\ref{table:simple} can be viewed as the structure shown in Figure~\ref{code:simple}.

\begin{table}[H]
  \caption{A simple table oriented such that columns name properties.}
\label{table:simple}
\begin{tabular}{r | l | c | l}

\textbf{ShipDate}& \textbf{Item}& \textbf{Qty}& \textbf{UnitPrice} \\ \hhline{=|=|=|=}
        6/15/21	      & Widget 123   &	1	   &  \$10.50 \\
        6/15/21	      & Gadget 234   &	2	   &  \$12.80 \\
        6/15/21	      & Foobar 344   &	1	   &  \$100.00
\end{tabular}
\end{table}

\begin{figure}[H]
    \caption{Table~\ref{table:simple} viewed as an array of map structures.}
    \label{code:simple}
\begin{lstlisting}[language=JavaScript]

[{"ShipDate":  "2021-06-15", "Item":  "Widget 123", "Qty": 1.0, "UnitPrice": 10.5},
 {"ShipDate":  "2021-06-15", "Item":  "Gadget 234", "Qty": 2.0, "UnitPrice": 12.8},
 {"ShipDate":  "2021-06-15", "Item":  "Foobar 344", "Qty": 1.0, "UnitPrice": 100.0}]
\end{lstlisting}
\end{figure}

The built-in function \stt{\$readSpreadsheet} reads spreadsheets.
An example usage is:\\
\vspace{3mm}
\stt{\$readSpreadsheet("data/spreadsheets/ExampleInvoiceInfo.xlsx", "Sales Info")} \\
\vspace{3mm}
where the first argument names an Excel file and the second names a sheet in that spreadsheet.
If the table is transposed (so that all the properties are in its first column, and each row concerns a different object), a third argument with value \stt{true} can be specified to access the data in the more useful orientation.

\section{Datalog features of RADmapper} % Formerly titled "Working with Data Having Complex Interrelations."
%[This section will introduce provisions for expressing maps to/from relational DBs, where schema are assumed.]

%Some situations call for more complex query and restructuring functionality than what has been illustrated above.
%Everything to this point in the discussion could be performed easily with JSONata~\cite{Jsonata.org2021}, a language for querying and restructuring JSON-like data.
%JSONata is used, for example, in the Open Integration Hub~\cite{OIH2021}, an open software platform that received its initial funding in 2017 from the German Federal Government,
%Federal Ministry for Economic Affairs and Energy. % https://www.elastic.io/pressroom/open-integration-hub-data-synchronisation/
%JSONata is also used in Node-RED~\cite{Node-Red2021}.

% ToDo: This really belongs elsewhere.

RADmapper provides a superset of the functionality of JSONata, but more importantly, it supports a second paradigm for navigating data and some very different usage scenarios.
The JSONata viewpoint could be described as one where a tree (or equivalently, a JSON object) is navigated from the root.
Decades of experience, dating back to the early days of EDI, has shown that tree-based organization such as JSON objects is a quite reasonable choice where the communication of document-like information (e.g. ``messaging'') is needed.
The point of an interoperable exchange form such as RADmapper, however, includes additional requirements.
Among these is the ability to describe relationships to and from data possessing complex interrelationship, for example, data described by a relational schema or knowledge graph.
To argue that APIs to the back-end system already do this work is to miss the point:
we are not trying to replace a back-end system function, but to describe the relationships in ways that help business analysts, programmers, and machine agents.
RADmapper, and particularly its \textit{AST strategy} described in Section~\ref{NYI} is targeted towards new integration scenarios that involve higher levels of automation and joint (human/AI) cognitive work.

% To illustrate the challenge of using a JSONata-like engine for data having complex interrelations, suppose, for example\ldots. [Discussion of the OWL example]


%\footnote{That example uses the JSONata convention that \stt{\$} is the \textit{context reference} always bound to whatever is the data at the time of reference.}
\subsection{Mapping  Networked Data}

Binding sets, in themselves, are not too useful; you might be wondering why we even discuss them.
The answer is that they are crucial to mapping networked data and doing in-place updates.
Once you have the binding sets, you are halfway there; what remains is to use the binding sets to produce target data.
This section describes that process, beginning with definitions of some terms just used:

\begin{description}
\item[networked data] a collection of data that contains pointers to other parts of the same data collection.

  For example, we could have a data in triples that includes information about Bob.
  Instead of repeating everything we know about Bob each time he is referenced in the data,
  networked data can use references to that same data.
  Resolving the reference (which might be implemented as a UUID, for example) connects to the information about Bob.
\item[in-place update] the idea that the mapping task might involve updating an existing collection of data, rather than
  defining new data about it.

  For example, on Bob's 30th birthday, we don't just add the fact \stt{\{'person/name' : 'Bob', 'person/age' : 30\}}, we
  retract the fact that Bob is 29 and assert the new fact.
\end{description}

Before we can talk about mapping networked data and in-place updating, it is important to recognize that these activities require
some additional knowledge about the (target) data.
For example, how do we know
(a) that an action is intended to update some referenced data rather than add new additional information about it, and
(b) whether to use a pointer to reference some data rather than just put the data there?
We need more information about the data.
Specifically, to perform these more complex mapping tasks we have to know:
(1) the cardinality of each attribute,
(2) the type of each attribute (or at least the distinction between references and data types), and
(3) attributes that provide keys (that is, uniquely identify an object of a given type).

% ToDo: This probably belongs somewhere else. (Getting into too much detail!)
Notice that condition (3) mentions the idea of object type.
It is not the case that objects need to have any inherent notion of type to use RADmapper mapping.
It is enough that the programmer recognizes the type by the attributes it possesses.
(This is the so called \textit{duck typing} --- if it walks like a duck and quacks like a duck it is a duck.)
Thus, an object that has an email address and a phone number might be recognized as a customer.
% You already covered this above!
%That said, programmers are likely to have an easier time of it if they explicitly hint at the types of things using namespaced attributes.
%By \textit{namespaced attributes} we mean the idea that the name of the attribute hints at the object type it appears in.
%Thus the attribute for a customers email might be the name-value pair \stt{"customer/email" : "bob@example.com"}.

\subsubsection{Complex mapping task example}

The following example illustrates mapping of a network of Web Ontology Language (OWL) data to a relational form.
The source OWL data used is simplified from actual OWL data to allow easier discussion.
The data consists of objects of two types, one is OWL classes; these have the value  \stt{owl/Class} in their \stt{rdf/type} attribute.
The other is OWL properties (\stt{owl/ObjectProperty}).
The simplifications include using single values for \stt{rdfs/domain}, \stt{rdfs/range}, and \stt{rdfs/subClassOf}.
An OWL class and property is depicted in Figure~\ref{code:endurant}.

\begin{figure}[H]
  \caption{An object (owl/Class) and a relation (owl/ObjectProperty) in the source population.
    These are somewhat simplified from realistic OWL data.}
  \label{code:endurant}
\begin{lstlisting}[numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
{'resource/iri'       : 'dol/endurant',
 'resource/name'      : 'endurant',
 'resource/namespace' : 'dol',
 'rdf/type'           : 'owl/Class',
 'rdfs/comment'       : ['The main characteristic of endurants is...'],
 'rdfs/subClassOf     : :dol/spatio-temporal-particular,
 'owl/disjointWith'   : ['dol/abstract', 'dol/quality', 'dol/perdurant']}

{'resource/iri'       : 'dol/participant',
 'resource/name'      : 'participant',
 'resource/namespace' : 'dol',
 'rdf/type'           : 'owl/ObjectProperty',
 'rdfs/comment'       : ['The immediate relation holding between endurants and perdurants...'],
 'owl/inverseOf'      : 'dol/participant-in',
 'rdfs/domain'        : 'dol/perdurant',
 'rdfs/range'         : 'dol/endurant'}
\end{lstlisting}
\end{figure}

The target data we'll be creating consists of three kinds of things: schema, tables, and columns.
Even with this simple data, there are a few options for designing the relational schema.
The following are design choices that define the form of the mapping target:
\begin{enumerate}
\item Both \stt{owl/Class} and \stt{owl/ObjectProperty} can have \stt{rdfs/comment} and the relationship is one-to-many.
  A single table with keys consisting of the resource IRI and comment text will suffice.

\item \stt{rdf/type} is one-to-one with the class. Though the possible values are limited to just a few such as \stt{owl/Class} and
  \stt{owl/ObjectProperty}, we will represent it with a string naming the type.

\item \stt{resource/name} and \stt{resource/namespace} are also one-to-one and are just the two parts of \stt{resource/iri} and could be computed, but we will store these in the class table too.

\item We will assume \stt{rdfs/domain},  \stt{rdfs/range}, and \stt{rdfs/subClassOf} are single-valued. Typically they are not in a real OWL ontology.

\item We will assume that we want to support storage of individuals of the types defined by OWL classes.
  Though our approach here is not at all reflective of description logic, where class subsumption is the primary kind of inference,
  mapping will produce a two-column table where one column is the individual's IRI and the other is the foreign key of a class to which it belongs.

\item We will assume that all relations are conceptually binary.
  Thus storing individuals means that for each \stt{owl/ObjectProperty} mapping will produce a two-column table to represent both a relation and its inverse (``inverse pairs'') where an inverse is defined.
  Such a table works in both directions (the relation and its inverse), so we will have to prevent creating a table for one member of each inverse pair.

\end{enumerate}

% To keep things simple, we'll omit some otherwise useful considerations like identifying what columns define keys;
%[This belongs elsewhere]: A table keyed by a class \stt{resource/iri} will be defined to store the \stt{resource/name} and \stt{resource/namespace}.
%
With the above considerations in mind, it becomes apparent that some of the work involves nothing more than storing class and property metadata into tables we can define ahead of time.
The \stt{owl/ObjectProperty} definitions, however, entails one new table for each relation (or relation pair if an inverse is defined).
The rows of these tables would be populated by instances of the classes specified by \stt{rdfs/domain} and \stt{rdfs/range}.
This information is not in the ontology, but Figure~\ref{code:static-ddl} depicts the static tables in typical relational DDL.
These are populated by the ontology \stt{owl/Class} content of the
Figure~\ref{code:dynamic-ddl-dml} depicts tables that would be created.

% ToDo: Get listinglst for SQL
\begin{figure}[H]
  \caption{Static DDL for storing class and object relation metadata.
  The mapping will generate information equivalent to DML to populate this from the source data.}
  \label{code:static-ddl}
\begin{lstlisting}[numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
  CREATE SCHEMA typicalOWL;

  CREATE TABLE ObjectDefinition
    (resourceIRI       VARCHAR(300) primary key,
     resourceLabel     VARCHAR(300) not null,
     resourceNamespace VARCHAR(300) not null);

  CREATE TABLE ClassDefinition
    (resourceIRI VARCHAR(300) primary key,
     subClassOf  VARCHAR(300) references ClassDefinition);

  CREATE TABLE ObjectClass
    (resourceIRI VARCHAR(300) primary key,
     class       VARCHAR(300) references ClassDefinition);

  CREATE TABLE DisjointClass
    (disjointID  INT primary key,
     disjoint1   VARCHAR(300) not null references ObjectDefinition,
     disjoint2   VARCHAR(300) not null references ObjectDefinition);

  CREATE TABLE ResourceComment
    (commentID    INT primary key,
     resourceIRI  VARCHAR(300) not null references ObjectDefinition,
     commentText  VARCHAR(900) not null);

  CREATE TABLE PropertyDefinition
    (resourceIRI    VARCHAR(300) primary key,
     relationDomain VARCHAR(300) references ObjectDefinition,
     relationRange  VARCHAR(300) references ObjectDefinition);
\end{lstlisting}
\end{figure}

Figure~\ref{code:dynamic-ddl-dml} depicts the result of mapping data from Figure~\ref{code:endurant} using a mapping
specification that will be described below.

\begin{figure}[H]
  \caption{Result of mapping the data depicted in Figure~\ref{code:endurant}.
    This specifies content equivalent to
    (1) DML to capture metadata for owl/Class and owl/ObjectProperty objects in the static tables defined above, and
    (2) DDL to create tables for owl/ObjectProperty objects.}
  \label{code:dynamic-ddl-dml}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
  {'instance-of'  : 'insert-row',
   'table'        : 'ObjectDefinition',
   'content'      : [{'resourceIRI'       : 'dol/endurant'},
                     {'resourceLabel'     : 'endurant'},
                     {'resourceNamespace' : 'dol'}]}

  {'instance-of'  : 'insert-row',
   'table'        : 'ClassDefinition',
   'content'      : [{'resourceIRI'    : 'dol/endurant'},
                     {'subClassOf'     : 'dol/spatio-temporal-particular'}]}

  {'instance-of'  : 'insert-row',
   'table'        : 'DisjointClass',
   'content'      : [{'disjointID'   ; 1},
                     {'disjoint1'    : 'dol/endurant'},
                     {'disjoint2'    : 'dol/abstract'}]} /* ... (Two more disjoints elided.) */

  {'instance-of'  : 'insert-row',
   'table'        : 'ResourceComment',
   'content'      : [{'commentID'   : 1},
                     {'resourceIRI' : 'dol/endurant'},
                     {'commentText' : 'The main characteristic of endurants is...'}]}

  /* Similar content for the ObjectPropery dol/participant is elided. */

  {'instance-of'  : 'insert-row',
   'table'        : 'PropertyDefinition',
   'content'      : [{'resourceIRI'    : 'dol/participant'},
                     {'relationDomain' : 'dol/perdurant'},
                     {'relationRange'  : 'dol/endurant'}]}

  /* The DDL for the participant table: */

  {'instance-of' : 'create-table',
   'table'       : 'DOLparticipant',
   'columns'     : [{'colName' : 'propertyID',
                     'dtype'   : {'type' : 'varchar', 'size' : 300, 'key' : 'primary'}},
                    {'colName' : 'role1',
                     'dtype'   : {'type' : 'varchar', 'size' : 300, 'ref' : 'ObjectDefinition'}},
                    {'colName' : 'role2',
                     'dtype'   : {'type' : 'varchar', 'size' : 300, 'ref' : 'ObjectDefinition'}}]}
\end{lstlisting}
\end{figure}

%Schema for the target data (the table definitions, etc.) is depicted in Figure ~\ref{code:example-schema-1}.
%The object types define attributes (\stt{db/attrs}) and keys (\stt{db/key}).
%Each attribute has a type (\stt{db/type}) and a cardinality (\stt{db/cardinality}.
%The \stt{db/type} can be any primitive type defined (e.g. strings, numbers, UUID, etc.) or \stt{object}, meaning that
%the attribute is populated by either references to other objects (foreign keys) or objects in-lined in the structure, the choice depending on the value of \stt{db/in-line?}.

%The top-level entries in this schema are identified
%by the strings ``schema'', ``table'', and ``column'' which have no particular significance but might be used in
%error reporting (or we'll get rid of them).

% ToDo: Did I decide to move :db/key ??? If so, do I really need the nested structure?
% ToDo: Do I really want table/schema, or do I want schema/tables?
% \begin{figure}[H]
%   \caption{A schema for the target data}
%   \label{code:example-schema-1}
% \begin{lstlisting}[numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
%   [{'schema' : {'db/attrs'  : [{'schema/name'   : {'db/type' : 'string', 'db/cardinality' : 'one'}}],
%                 'db/key'    : ['schema/name']}}
%
%    {'table'  : {'db/attrs'  : [{'table/name'    : {'db/type' : 'string', 'db/cardinality' : 'one' },
%                                 'table/schema'  : {'db/type' : 'object', 'db/cardinality' : 'one',
%                                                    'db/in-line?' : true},
%                                 'table/columns' : {'db/type' : 'object', 'db/cardinality' : 'many'}}],
%                 'db/key'    : ['table/schema', 'table/name']}}
%
%    {'column' : {'db/attrs'  : [{'column/name'   : {'db/type' : 'string', 'db/cardinality' : 'one'}},
%                                {'column/type'   : {'db/type' : 'string', 'db/cardinality' : 'one'}},
%                                {'column/table'  : {'db/type' : 'object', 'db/cardinality' : 'one'}}],
%                 'db/key'    : ['column/table', 'column/name']}}]
% \end{lstlisting}
% \end{figure}

% The \stt{db/cardinality} of all the attributes in ``one'' except in the case of \stt{table/columns} which is ``many''.
% (See Line 7 of the figure.)
% Cardinality of one means that actions on this attribute of an object necessarily either creates the triple or updates it.
% There will never be two triples about this attribute in the target population where the first two elements of the triple are identical.
% Cardinality of many means that that there could be multiple triples for the attribute.
% Keep in mind that the elements of a triple are always atomic.
% To represent $n$ values there are $n$ triples having different values for the third element of the triple.
% Also, the underlying datalog tool preserves the order of elements in arrays.
%
% Line 7 in the figure demonstrates the use of the optional, \stt{db/in-line?} schema feature.
% On Line7 \stt{db/in-line?} is set to true (the default is false).
% \stt{db/in-line?} true directs the mapper to create structures rather than references.
% Relation technology provides nothing quite like in-lining, but we demonstrate its use in the example below nonetheless.
% In the example, schema are described by just their name; entire objects are serialized like this: \stt{\{schema/name ``some schema''\}}.
% It seems reasonable in these circumstances to in-line, much less so in the case of the back-pointer \stt{table/columns}.

Figure \ref{code:mapping-owl-to-rdbms} depicts the complete specification of a transformation of the source.
\stt{\$transform} is a side-effecting function that takes three arguments, a data context, a binding set, and an express function;
it returns a connection to resulting data.
(Returning the data itself might not be reasonable in the case that it is very large and managed by a database.)
When the binding set argument is a literal call to \stt{query} it is possible for the parser to do syntax checking between
the \stt{query} and \stt{express}.

The \stt{query} produces a binding set for the source data.
The \stt{express} defines how values from the binding set are used in the target population.

% ToDo: Check out the URL about better listing javascript
% https://mysnippets443.wordpress.com/2015/11/28/latex-insert-javascript-code-with-lstlisting-package/

\begin{figure}[H]
  \caption{Mapping the example OWL to the relational database schema}
  \label{code:mapping-owl-to-rdbms}
\begin{lstlisting}[language=JavaScript,numberstyle=\scriptsize,basicstyle=\ttfamily\scriptsize,numbers=left,stepnumber=1,breaklines=true]
  (   $data := $read('data/testing/owl-example.edn');

  $qtype  := query($rdfType, $extraTrips)
               { [?class :rdf/type            $rdfType]
                 [?class :resource/iri        ?class-iri]
                 [?class :resource/namespace  ?class-ns]
                 [?class :resource/name       ?class-name]
                 /* ToDo: $extraTrips */
               };  /* Defines a higher-order function, a template of sorts. */

  $etype  := enforce($tableType)
              {  {'instance-of'  : 'insert-row',
                  'table'        : $tableType,
                  'content'      : {'resourceIRI'       : ?class-iri,
                                    'resourceNamespace' : ?class-ns,
                                    'resourceLabel'     : ?class-name}}
                           }; /* Likewise, for an enforce template. */
                              /* The target tables for objects and relations a very similar. */

  $quClass := $qtype('owl/Class');     /* Use the template, here and the next three assignments. */

  /* This one doesn't just specify a value for $rdfType, but for $extraTrips. */
  $quProp       := $qtype('owl/ObjectProperty'); /* ToDo: ,queryTriples{[?class :rdfs/domain ?domain] [?class :rdfs/range ?range]}); */
  $enClassTable := $etype('ClassDefinition');
  $enPropTable  := $etype('PropertyDefinition');

  /* Run the class query; return a collection of binding sets about classes. */
  $clasBsets := $quClass($data);

  /* We start enforcing with no data, thus the third argument is []. */
  $tar_data := $reduce($clasBsets, $enClassTable, []);

  /* Get bindings sets for the ObjectProperties and make similar tables. */
  $propBsets := $quProp($data);

  /* We pass in the target data created so far. */
  $reduce($propBsets, $enPropTable, $tar_data) /* The code block returns the target data. */
)
\end{lstlisting}
\end{figure}


% $.$transform(
%     query( [?class :rdf/type            'owl/Class']
%             [?class :resource/iri        ?class-iri]
%             [?class :resource/namespace  ?ns]
%             [?class :resource/name       ?class-name]
%             [?rel   :rdfs/domain         ?class-iri]
%             [?rel   :rdf/type            ('owl/ObjectProperty' or 'owl/DataProperty')]
%             [?rel   :rdfs/range          ?rel-range]
%             [?rel   :resource/name       ?rel-name])
%     express( {'table/name'     : ?class-name,
%                'table/schema'   : {'schema/name'  : ?ns},
%                'table/columns'  : {'column/name'  : ?rel-name,
%                                    'column/type'  : ?rel-range,
%                                    'column/table' : ?table-ent}} as ?table-ent))
%
%We'll walk through the example line by line.
%On Line 1 \stt{\$transform} receives data from the context variable. [Other methods will be defined.] % ToDo
%On Line 2 we constrain the search to just those entities that have \stt{rdf/type} containing the string ``owl/Class''.
%On Lines 3, 4, and 5 we bind variables to attribute values of that entity.
%If instead of mapping every namespace in the source data we wanted to limit mapping to a single namespace,
%we could have specified a value or expression for \stt{resource/namespace} on Line 4 rather than the variable \stt{?ns}.
%For example, we could have specified ``dol'' here, that happens to refer to the DOLCE ontology namespace.
%(See the example data in Figure ~\ref{code:endurant}.)
%
%Lines 6, 7, 8 and 9 match and bind a second entity.
%Line 6 uses the variable \stt{?class-iri} which was bound on Line 3; thus a relational join is performed.
%According to Line 7 this entity must have \stt{rdf/type} of either ``owl/ObjectProperty'' or ``owl/DataProperty''.
%Lines 8 and 9 bind the \stt{rdfs/range} and \stt{resource/name} respectively.
%
%With a call to \stt{express}, Line 10 defines  a higher-order function.
%The design of \stt{\$transform}, \stt{query} and \stt{express} were factored as they are to facilitate debugging.
%For example, \stt{query} can be run on context data so that the resulting binding set may be verified;
%\stt{express} can be applied to a small hand-coded binding set to verify that the intended mapping is taking place.
%

% ToDo: This needs work.
The example dataset from DOLCE is fairly large.
Let's suppose it contains 50 classes, each involved in 10 relations.
That suggests a collection of 500 binding sets.
That does not necessarily entail 500 structures like Lines 10 through 14, however.
In contrast to the JSONata-like operations, which maps physical structures to physical structures,
the mapping engine here is mapping between logical structures.
Specifically, a triple represents a fact and the database of triples need only represent a fact once.
It is the knowledge of keys and references provided by the schema that allows the mapping engine to construct physical structure
from the logical relationship defined by the mapping specification.

\subsubsection{Summary of the complex mapping work process}
A good approach to complex mapping tasks might start with performing \stt{query} on the data.

%Since it is likely that we do not have use for the bindings of the entity identifiers bound to \stt{?e} and \stt{?pn}, there is optional syntax in the definition to avoid returning them.
%For example, \stt{queryCellByName := query(\$name)\textbf{(?cellNum)}\{[?e 'name' \$name] \ldots\}} would return a binding set containing %only values for \stt{?cellNum}, if any.

\subsubsection{In-place Updates}

\textbf{[This part needs to be updated.]} Used alone in code, \stt{query} does not fit the pattern of a JSONata-like capability.
JSONata is effective and concise because it allow one to thread data through a pipeline of primitive transformations.
If you place a \stt{query} call anywhere in that pipeline, you lose all the data except what is specifically captured by \stt{query}.
There are certainly instances where that is useful, but is \stt{query} any easier than pure JSONata in these circumstances?\footnote{Stakeholders, do you have
  examples where you think \stt{query} might be better?
  Nothing comes to me, at the moment.
  There is also the matter of getting back an object keyed by binding variables.
  Thus far we haven't defined ways to manipulate that.}
Perhaps the unique value of \stt{query} is as an argument to higher-level functions to do tasks such as in-place and bi-directional updating.
Therefore, discussed next is (1) a new construct called \stt{express} and (2) how \stt{query} and \stt{express} can be used as arguments to a higher-order function \stt{\$transform} to do in-place updating.

\subsection{Working with multiple sources}

\subsection{Working with knowledge graphs}

% [[https://github.com/replikativ/datahike/blob/main/doc/schema.md][Schema-on-read/write discussion]]
%[Describe the need for schemas, data-on-read/data-on-write, etc..]
%[Discuss the use of namespaces.]
%[Discuss what can be done with keys.]

% working with relational data, and exchange forms like EDI requires more functionality.
% The language borrows from QVT-r to achieve these requirements.

\section{Use Cases}

\subsection{Interoperable Mapping Tables}

\subsection{Integration Flows}

\subsection{Data Catalogs and Knowledge Graphs}

\subsection{Data Validation}

\subsection{Joint Cognitive Work / Lo-Code Tools}

\section{Specification}

[This section will include a feature-by-feature description of the language similar to a language reference manual. Right now I've just listed the functions we think are needed.]

\subsection{Language Syntax}
This section is apt to be rewritten several times as the features of the language emerge.

\subsubsection{JSONata Subset}
[I haven't found a formal definition (e.g. BNF) for JSONata, but the following \textit{seems to work}. Not yet complete.]

\begin{Verbatim}[fontsize=\footnotesize]

<content> ::= <code-block> | <exp>

<code-block> ::= '('  (<exp-or-assignment> ';')* ')'

<exp-or-assignment> ::= <exp> | <assignment>

<exp> ::= ( <filter-exp> | <binary-exp> | (<builtin-un-op> <exp>) | <paren-delimited-exp> |
            <square-delimited-exp> |<fn-call> | <literal> | <field> | <id> )
          <conditional-tail>?

<binary-exp> ::= <operand-exp> <binary-op> <exp>

<operand-exp> ::= <field> | <id> | literal | <fn-call> | <delimited> | <unary-op-exp>

<filter-exp> ::=  <operand-exp> '[' <exp> ']'

<conditional-tail> ::= '?'  <exp> ':' <exp>

<range-exp> ::= '[' <exp> '..' <exp> ']'

<fn-call> ::=  <id> '(' (<exp> (, <exp>)*)? ')'

<fn-def> ::= 'function' '(' (<id> (',' <id>)*)? ')' '{' <exp> '}'

<js-map> ::= "{" (<map-pair> (',' <map-pair>)*)? "}"

<map-pair> ::=  <string>" ":" <json-data>

<json-data> ::= STRING | NUMBER | <json-array>

<json-array> :: = '[' (<json-data> (',' <json-data>)*)? ']'

<literal> ::= STRING | NUMBER | 'true' | 'false' | <regex> | <js-map>

<regex> (conforms to JavaScript's implementation)

<id> (a string starting with a \$... More on this later.)

\end{Verbatim}

%\subsection{Table of elementary language features}
%
%\begin{table}[H]
%\begin{tabular}{l | l }
%\textbf{Task}                       & \textbf{Example}       \\ \hhline{=|=}
%Access (or navigate)                & Address.PhoneNumber    \\
%Select from array (simple)          & {[}2{]}                \\
%Select from array (from end)        & {[}-2{]}               \\
%Select all from array               & (done implicitly)      \\
%Select a subset of array            & {[}{[}0..2{]}{]}       \\
%Entire input document               & \$                     \\
%Simple query                        & Phone{[}type='mobile'{]} \\
%Select values of all fields         & Address.*                \\
%Select value from any child         & *.Postcode               \\
%Select arbitrarily deep             & **.Postcode              \\
%Concat                              & 'a' \& 'b'               \\
%Usual numeric operators             &  +,-,*,/                 \\
%Array constructors                  &                          \\
%Object Constructors                 & Phone\{type: number\}    \\
%Object Constructors (force array)   & Phone\{type: number{[}{]}\} \\
%Code Block                          & (exp1; exp2; exp3)          \\
%Value as key in result              & Account.Order.Product\{`Product Name`: Price\} \\
%Map                                 & seq.exp                                        \\
%Filter                              & seq{[}exp{]}                                   \\
%Reduce (group and aggregate)        & seq\{exp:exp, exp:exp\}                       \\
%Sort                                & seq \textasciicircum (exp)                     \\
%Index                               & seq \# \$var                                   \\
%Join                                & seq @ \$var                                    \\
%Functions (in-line)                 & function(\$x) : \{()\};                       \\
%Naming functions                    & $myfunc = function($x)                        \\
%Context variable                    & \$                                             \\
%Root context variable               & $$                                             \\
%Conditional expression              & pred ? exp : exp                               \\
%Variable binding                    & \$my\_var := "value"                           \\
%Function chaining                   & value $\sim$\textgreater{} $f2 -> $f3          \\
%Regular expressions (like JS)       & /ab123/                                        \\
%Time                                & $now(), $millis()                              \\
%Transform                           & head $\sim$\textgreater | location | update {[},delete{]} |  \\
%Example variable binding            & [needs investigation] \\ %  JSONata  & library.loans@$l.books@$b{[}$l.isbn=$b.isbn{]}.\{ 'title': $b.title, 'customer': $l.customer \}
%Type coersion                       & asType(obj, typespec)                 \\
%Type checking                       & isTypeOf(obj, typespec)               \\
%Coersion to integer                 & toInteger(x)                          \\
%Coersion to real                    & toReal(x)                             \\
%Returning a substring               & substring()
%\end{tabular}
%\end{table}
\bibliography{/home/pdenno/Documents/bibtex/library}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "interop-mapping"
%%% End:
